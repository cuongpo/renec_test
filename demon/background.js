import{bn as d,Y as O,P as m,bo as P,ag as h,ao as J,ai as Q,ah as S,aj as X,a1 as W,aZ as Y,bp as Z,bd as ee,af as N,C as j,W as F,bq as K,M as $,Q as M,S as U,aA as A,aa as te,B as ne,b as re}from"./assets/use-approve-transaction-info.9a9548e3.js";async function f(s){return(await chrome.storage.local.get([s]))[s]||null}function _(s){try{return s==="undefined"?void 0:JSON.parse(s??"")}catch{return}}async function y(s,e){try{const t=await f(s);return _(t)??e}catch{return e}}const oe="wallet_selectors",se="wallet_trusted_apps",ie="wallet_idle_timer",ae="wallet_locked",ce="wallet_unlocked",le="web_locked",ue="web_session";async function de(){return _(await f(oe))?.address}async function k(s,e){let t=e||await de();const n=_(await f(se));let r=[];n&&Object.keys(n).length&&(t||(t=Object.keys(n)[0]),r=n[t]||[]);const o=r.findIndex(i=>i.url===s);return{isExist:Boolean(o>=0),selectedAccountAddress:t,findIndex:o,trustedAppsStorage:n,trustedApps:r}}async function we(){const s=await f(ce),e=await f(le),t=await f(ue),n=_(await f(ie))||{idleTime:10*60*1e3},o=Date.now()-new Date(t).getTime()>n.idleTime;return!(e||s&&(!t||o))}async function fe(){return Boolean(await f(ae))}function H(){return!(typeof window<"u"&&typeof window.document<"u")}const p={SEND_TRANSACTION:"send-transaction",SIGN_TRANSACTION:"sign-transaction",SIGN_TRANSACTIONS:"sign-transactions",SIGN_MESSAGE:"sign-message"},R={...p,CONNECT:"connect"},pe="demon-channel-popup-response",ge="demon-channel-worker",he="demon-solana-channel",Se="demon-solana-connect",Ae="demon-solana-send-transaction",me="demon-solana-sign-transaction",Ee="demon-solana-sign-transactions",Te="demon-solana-sign-message",Ne="demon-solana-close-window",ye="demon-solana-is-wallet-connected";class u{static _requestId=1;static _responseResolvers={};static requestUiAction(e,t){return new Promise(async(n,r)=>{const o=u.nextRequestId(),i=await e(o);u.addResponseResolver(o,a=>n({...a,window:i}),r),chrome.windows.onRemoved.addListener(async a=>{a===i.id&&(!t||!await t(o))&&(u.removeResponseResolver(o),n({id:o,result:void 0,error:void 0,windowClosed:!0,window:i}))})})}static async requestUiActionWithManager(e,t,n,r,o){let i;const a=await u.requestUiAction(async c=>{const l=await e(c);return r!==void 0&&l.id!==void 0&&t.add(n,r,l.id),l},o);return t.remove(n,r,i?.id),a}static resolveResponse(e,t,n){const r=u.getResponseResolver(e);if(!r)throw new Error(`unable to find response resolver for: ${e}`);const[o]=r;u.removeResponseResolver(e),o({id:e,result:t,error:n,windowClosed:void 0})}static addResponseResolver(e,t,n){return u._responseResolvers[e]=[t,n],e}static getResponseResolver(e){return u._responseResolvers[e]}static nextRequestId(){const e=u._requestId;return u._requestId+=1,e}static removeResponseResolver(e){delete u._responseResolvers[e]}static async handlePopupUiResponse(e){const{id:t,result:n,error:r}=e;return console.log("handle popup ui response",e),u.resolveResponse(t,n,r),"Success"}static subscribeResponse(e){d.addEventListenerFromAnywhereInExtension((t,n,r)=>{if(t.channel!==e||!H()&&chrome&&chrome?.runtime?.id&&n.id!==chrome.runtime.id)return;const o=t.data.id;return u.handlePopupUiResponse(t.data).then(i=>{r({id:o,result:i})}).catch(i=>{r({id:o,error:i.toString()})}),!0})}}class Ie{mapper;constructor(){this.mapper=new Map([[p.SIGN_MESSAGE,new Map],[p.SIGN_TRANSACTION,new Map],[p.SIGN_TRANSACTIONS,new Map]])}add=(e,t,n)=>{const r=this.mapper.get(e)?.get(t);this.mapper.get(e)?.set(t,r?r.add(n):new Set([n]))};remove=(e,t,n)=>{if(t===void 0||n===void 0)return;const r=this.mapper.get(e)?.get(t);r?.size&&r.size!==0&&(r.delete(n),this.mapper.get(e)?.set(t,r))};closeWindows=(e,t)=>{t?(this.mapper.get(t)?.get(e)?.forEach(d.closeWindow),this.mapper.get(t)?.delete(e)):this.mapper.forEach((n,r)=>{this.mapper.get(r)?.get(e)?.forEach(d.closeWindow),this.mapper.get(r)?.delete(e)})}}function Oe(){d.addEventListenerFromWebpage(async(s,e,t)=>{if(s.channel!==he)return;const{method:n,params:r}=s;switch(n){case Se:t(await ve(e));break;case Ae:t(await Ce(r,e));break;case me:t(await be(r,e));break;case Ee:t(await Le(r,e));break;case Te:t(await We(r,e));break;case Ne:t(await _e(r,e));break;case ye:t(await Re(r,e));break}})}async function v(s,e){if(!await fe())return chrome.tabs.create({url:chrome.runtime.getURL("index.html")}),{error:"Please create wallet or import accounts!"};if(e){const{isExist:t}=await k(s.origin,e);if(!t)return{error:"Please connect wallet!"}}return{error:void 0}}const b=new Ie,I=new Map,z="requestId expired";async function C(s,e){const t=await d.getLastFocusedWindow();return`title=${s.tab.title||""}&url=${s.origin}&logo=${s.tab.favIconUrl||""}&requestId=${e}&fromWindowId=${t.id}`}async function ve(s){const e=await v(s);if(e.error)return{error:e.error};const t=await we(),{isExist:n,selectedAccountAddress:r}=await k(s.origin);if(t&&n)return{result:r};const o=await u.requestUiAction(async i=>{const a=`index.html#/connect-app?${await C(s,i)}`,c=I.get(s.origin);if(c!==void 0)return await u.resolveResponse(c.requestId,void 0,z),c.window.tabs?.length&&chrome.tabs.update(c.window.tabs[0].id,{url:a}),chrome.windows.update(c.window.id,{focused:!0}),c.window;const l=await O(a);return s.origin!==void 0&&l.id!==void 0&&I.set(s.origin,{window:l,requestId:i}),l});if(I.delete(s.origin),o.error)return console.log("require ui action error",o),o.error!==z&&d.closeWindow(o.window.id),{error:o.error};if(!o.windowClosed)d.closeWindow(o.window.id);else return{error:"User reject connect!"};return{result:o.result.address}}async function be(s,e){const[t,n]=s,r=await v(e,n);if(r.error)return{error:r.error};const o=await u.requestUiActionWithManager(async i=>O(`index.html#/approve-transaction?${await C(e,i)}&txStr=${t}&walletAddress=${n}`),b,p.SIGN_TRANSACTION,e.origin);if(o.error)return console.log("require ui action error",o),d.closeWindow(o.window.id),{error:o.error};if(!o.windowClosed)d.closeWindow(o.window.id);else return{error:"user denied transaction signature"};return o.result?.length!==1?{error:"sign transaction response error!"}:{result:o.result[0]}}async function Ce(s,e){const[t,n]=s,r=await v(e,n);if(r.error)return{error:r.error};const o=await u.requestUiActionWithManager(async i=>O(`index.html#/send-transaction?${await C(e,i)}&txStr=${t}&walletAddress=${n}`),b,p.SEND_TRANSACTION,e.origin,async i=>{let a=!1;const c=await m.getStorage();return Object.entries(c).forEach(([l,g])=>{Object.entries(g).forEach(async([L,E])=>{E.find(D=>D.approveTransactionInfo?.requestId===i)&&(a=!0)})}),a});if(o.error)return console.log("require ui action error",o),d.closeWindow(o.window.id),{error:o.error};if(!o.windowClosed)d.closeWindow(o.window.id);else return{error:"user denied transaction signature"};return{result:o.result}}async function Le(s,e){const[t,n]=s,r=await v(e,n);if(r.error)return{error:r.error};const o=await u.requestUiActionWithManager(async i=>O(`index.html#/approve-transactions?${await C(e,i)}&txs=${t}&walletAddress=${n}`),b,p.SIGN_TRANSACTIONS,e.origin);if(o.error)return console.log("require ui action error",o),d.closeWindow(o.window.id),{error:o.error};if(!o.windowClosed)d.closeWindow(o.window.id);else return{error:"user denied sign transactions"};return{result:o.result}}async function We(s,e){const[t,n]=s,r=await v(e,n);if(r.error)return{error:r.error};const o=await u.requestUiActionWithManager(async i=>O(`index.html#/approve-message?${await C(e,i)}&message=${t}&walletAddress=${n}`),b,p.SIGN_MESSAGE,e.origin);if(o.error)return console.log("require ui action error",o),d.closeWindow(o.window.id),{error:o.error};if(!o.windowClosed)d.closeWindow(o.window.id);else return{error:"user denied sign message"};return{result:o.result}}async function _e(s,e){if(!e.origin)return{error:"sender.origin not found!"};const t=s[0]||void 0;if(t!==void 0&&!Object.values(R).includes(t))return{error:"Invalid type"};const n=I.get(e.origin);return(!t||t===R.CONNECT)&&n!==void 0&&(d.closeWindow(n?.window.id),I.delete(e.origin)),t!==R.CONNECT&&b.closeWindows(e.origin,t),{result:"success"}}async function Re(s,e){const[t]=s,{isExist:n}=await k(e.origin,t);return{result:n}}class x{constructor(e){this.payer=e}static local(){if(require("process"),!{}.ANCHOR_WALLET||{}.ANCHOR_WALLET==="")throw new Error("expected environment variable `ANCHOR_WALLET` is not set.");const e=P.fromSecretKey(Buffer.from(JSON.parse(require("fs").readFileSync({}.ANCHOR_WALLET,{encoding:"utf-8"}))));return new x(e)}async signTransaction(e){return e.partialSign(this.payer),e}async signAllTransactions(e){return e.map(t=>(t.partialSign(this.payer),t))}get publicKey(){return this.payer.publicKey}}class w{static async sendGaslessTransactionImpl(e,t,n,r,o){const i=new x(e?.provider?.account),a=await h.GaslessDapp.new(e.connection),c=new h.GaslessTransaction(e.connection,i,a);c.addInstructions(n),r?.length&&c.addInstructions(r),o?.length&&c.addSigners(o);const{feePayer:l}=await h.getGaslessInfo(e.connection);return await c.solveAndSubmitPuzzle(l,t)}static async getInstructions(e,t){const n={tokenAddress:t.tokenAddress,publicKey:new J(t.toAccount),amount:t.amount,isUseGasLess:!0,rentFee:t.rentFee};return await Q.getSendInstructions(e,n,t.tokenDecimals)}static async handleTransactionSend(e,t){let n;if(t.type===S.SEND&&(n=await w.getInstructions(e,t),!n))throw new Error("Cannot get instructions!");return await w.sendGaslessTransactionImpl(e,t.puzzle,n)}static async handleTransactionApprove(e,t){const n=t.puzzle,r=await h.POWPuzzle.solveAsync(h.Question.fromObject(n.question)),o={address:e.publicKey.toBase58(),solution:r.toString(16),...n},i=Math.floor(Date.now()/1e3);n.allowedSubmissionAt&&i<n.allowedSubmissionAt&&await h.sleep((n.allowedSubmissionAt-i)*1e3);const a=e.connection,c=X.from(W.decode(t.approveTransactionInfo.txStr));c.recentBlockhash=(await a.getRecentBlockhash()).blockhash,Y(c,e.provider?.account);const l={solution:JSON.stringify(o),txStr:W.encode(c.serialize({requireAllSignatures:!1}))};return await u.handlePopupUiResponse({id:t.approveTransactionInfo.requestId,result:l}),l}static async handleTransactionMintLock(e,t,n){const{tokenIn:r,tokenInDecimals:o,tokenOut:i,amountIn:a}=t.mintLockInfo,c=await Z(e,r,i,n),l=new ee(a*10**o),g=await c.pair.lockNMint(e.publicKey,l),{instructions:L,cleanupInstructions:E,signers:T}=g.compressIx(!0);return await w.sendGaslessTransactionImpl(e,t.puzzle,L,E,T)}static async sendGasLessTransaction(e,t,n){const r={...n},o=e.publicKey?.toBase58();try{r.status=N.PROCESSING,r.estimateTime=n.puzzle.allowedSubmissionAt*1e3,await m.updatePendingTransaction(o,t,r);let i;switch(n.type){case S.SEND:{i=await w.handleTransactionSend(e,n),r.signature=i;break}case S.APPROVE_TRANSACTION:{i=await w.handleTransactionApprove(e,n);break}case S.SWAP:throw new Error("Not impl!");case S.MINT_LOCK:{i=await w.handleTransactionMintLock(e,n,t),r.signature=i;break}}return r.status=N.SUCCESS,await m.updatePendingTransaction(o,t,r),i}catch(i){if(console.log("error",i),r.status=N.ERROR,r.error=i.message||"Send transaction failed!",await m.updatePendingTransaction(o,t,r),n.type===S.APPROVE_TRANSACTION)try{await u.handlePopupUiResponse({id:n.approveTransactionInfo.requestId,error:"Approve transaction failed!"})}catch(a){console.log("send response error",a)}}}}class B{static async getWallet(e,t){let n;const{walletIndex:r,importedPubkey:o}=e,i=await y(j,{}),a=await y(F,void 0),c=new K(t);if(o){if(!i)return;const l=i[o].secretKey;n=P.fromSecretKey(W.decode(l))}else{if(!a)return;if(r===void 0)throw new Error("walletIndex is undefined!");n=$(a?.seed,r,a?.derivationPath)}return await M.create(c,U.LOCAL,{account:n})}static async getWalletFromPrivateKeyOrIndex(e,t,n,r){const o=new K(e);let i;if(n!==void 0&&(i=$(t?.seed,n,t?.derivationPath)),r&&(i=P.fromSecretKey(W.decode(r))),!i)throw new Error("Cannot get account!");return await M.create(o,U.LOCAL,{account:i})}}function Pe(s){if(!!s.length){for(let e=s.length-1;e>=0;e--)if(s[e].status===N.PENDING)return s[e]}}function ke(s){const e=te.find(t=>t.slug===s);if(!e)throw new Error(`Network slug ${s} not found!`);return e}function xe(s,e,t){const n=e.find(o=>o.address===s);if(n)return{walletIndex:n.index};const r=t[s];if(r)return{secretKey:r.secretKey};throw new Error("Wallet info not found!")}class De{_isRunning={};executePendingSendTransactions(){this._isRunning={},setInterval(async()=>{console.log("interval");const e=await m.getStorage(),t=await y(F,void 0);if(!t)return;const n=await y(ne,[]),r=await y(j,{});Object.entries(e).forEach(([o,i])=>{Object.entries(i).forEach(async([a,c])=>{try{const l=`${o}.${a}`;if(A.get(this._isRunning,l))return;const g=ke(a),{walletIndex:L,secretKey:E}=xe(o,n,r),T=await B.getWalletFromPrivateKeyOrIndex(g.value,t,L,E);if(!T)throw new Error("Cannot get wallet!");if(c.find(V=>V.status===N.PROCESSING))return;const G=Pe(c);G&&(A.set(this._isRunning,l,!0),await w.sendGasLessTransaction(T,g.slug,G),A.set(this._isRunning,l,!1))}catch(l){console.log("error",l)}})})},3e3)}async executePendingSendTransaction({accountIndex:e,connection:t,pendingTransactionId:n}){const r=await B.getWallet(e,t.value);if(!r)throw new Error("Cannot get wallet!");const o=await m.getPendingTransaction(r.publicKey?.toBase58(),t.slug,n);if(!o)throw new Error("Pending transaction not found!");const i=`${r.publicKey?.toBase58()}.${t.slug}`;if(A.get(this._isRunning,i))return;A.set(this._isRunning,i,!0);const a=await w.sendGasLessTransaction(r,t.slug,o);return A.set(this._isRunning,i,!1),a}subscribe(e){d.addEventListenerFromAnywhereInExtension((t,n,r)=>{if(t.channel===e&&!(!H()&&chrome&&chrome?.runtime?.id&&n.id!==chrome.runtime.id)){switch(t.data.method){case"send-gasless-transaction":this.executePendingSendTransaction(t.data).then(o=>{console.log("resp",o),r({result:o})}).catch(o=>{r({error:o.toString()})});break;default:r({error:"method not found"});break}return!0}})}}globalThis.Buffer=re.Buffer;console.log("background script loaded");const q=new De;(function(){function s(){Oe(),u.subscribeResponse(pe),q.subscribe(ge),q.executePendingSendTransactions()}s()})();
